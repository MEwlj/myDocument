# 动态规划总结

动态规划可以分为三个部分

1. 动态规划的定义，决定dp数组是一维的还是二维的，决定dp[i]表示什么。
2. 边界条件，有时候dp[]在静态初始化长度的时候要+1，用多出来的行（列）来解决边界问题。
3. 状态转移方程：比如dp[i+1]往往与dp[1]到dp[i]的数据有关，如果只与dp[i]有关的话，甚至可以考虑不设置dp数组，采用滚动变量来表示不同状态。



## 归类1：滚动变量形式

如果dp[i+1]只与几个固定的状态有关，可以考虑把那几个固定的状态设置为变量的形式，在for循环中动态更新变量，选择其中的一个变量作为结果。

### 转移方程无判断条件

leetcode 第70题 爬楼梯：状态转移dp[i]只与dp[i-1]和dp[i-2]有关。

### 转移方程有判断条件

746题 使用最小花费爬楼梯，就要加Math.min来体现最小化花费。

## dp为集合类问题

- 22 括号生成：此题要返回生成括号的组合，给定n个括号，返回n个括号所有可能组合。当求n的时候，需要用到n以前的所有括号组合，因此采用List<List<String>> lists来模拟dp数组，lists的动态更新体现为lists.add(list)，list是一个临时集合，动态转移方程体现在list的更新上面，其思想表示为“(”+lists.get(j)+")"++lists.get(i-j-1)，满足i从0到n-1，这儿要用4个for循环。



## 归类2：问题切分

对于求第第n个xx最大值问题，把问题切分成n分，分别求第1个xx时最大值，第2个xx时最大值，...，第n个xx时的最大值。由于是求最值，转移方程应该都有判断条件。

- 198 打家劫舍 ：Math.min比较当前房屋和前一个房屋的较大值，来确定当前房屋的最大值。
  - 740 删除并获得点数：实质和198一样，若选择了x，就无法选择x-1和x+1。



# 贪心算法

贪心算法一般用于求最值，很多课程里说贪心算法寻找每一步的最优解，最后的结果不一定是最值。但是在leetcode中，贪心算法求最值的题屡见不鲜。有些求最值的题，可以通过求每一步的最优解得到。必须先通过数学归纳法得到结论：最值能够通过每一步的极值得到。

## 求解目标是判断条件类型

- 55 跳跃游戏：能否到底最后一个下标，只要>=nums.length即可，每一步判断所能到达的最大值，与nums.length进行比较。这个题不是求最值的问题。

## 求最值问题--最小值

- 45 跳跃游戏II：求到达数组最后一个位置的最小次数。其思想在55题的基础上，多了一个判断是否到达每一步所到终点的步骤，当foreach遍历数组时，若到达了前一步确定的最大值位置，此时确定接下来要跳出去的最大值位置，并把次数＋1.
