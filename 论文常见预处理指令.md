# 论文中常见预处理指令

# 1. strip()

1. 能够清除一段字符串首尾的空格，以及诸如‘\r\t\n’此类的转义字符。对于首尾的空格和转义字符能够清除，对于字符串内的空格无法清除。

2. lstrip()和rstrip()。第一个是只删头，第二个是只删尾巴。

3. [参考]:https://www.cnblogs.com/kaishirenshi/p/8610892.html

# 2.read

1. with open() as f后，常常用f.read()，此时读出来的只能是字符串，当读一段文本的时候，常常是把整个txt文件当做一个大的字符串来读取，因此常用的做法是

   ```python
   data = f.read().strip().split("\n")
   ```

2. pycharm中显示的字符串的格式为

   ![image-20210710151232970](./picture/常见预处理指令\image-20210710151232970.png)

​	可见，在一行的左右分别有记号，表明这是字符串。

# 3.sorted

1. sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。

   list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作

2. 语法规则

   ```python
   sorted(iterable, cmp=None, key=None, reverse=False)
   ```

3. [菜鸟]：https://www.runoob.com/python/python-func-sorted.html



# 4. split()

```
str.split(str="", num=string.count(str))
```

Python **split()** 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串

- str -- 分隔符，默认为所有的空字符，包括**空格、换行(\n)、制表符(\t)**等。
- num -- 分割次数。默认为 -1, 即分隔所有。

- 返回分割后的字符串列表。

[菜鸟](https://www.runoob.com/python/att-string-split.html)



# 5. defaultdict(list)

会构建一个默认value为list的字典，代码演示

```python
from collections import defaultdict
result = defaultdict(list)
data = [("p", 1), ("p", 2), ("p", 3),
        ("h", 1), ("h", 2), ("h", 3)]
 
for (key, value) in data:
    result[key].append(value)
print(result)#defaultdict(<class 'list'>, {'p': [1, 2, 3], 'h': [1, 2, 3]})
```

> https://blog.csdn.net/weixin_38145317/article/details/93175217

> https://blog.csdn.net/bandaye3/article/details/83479771?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant



# 6. np.where(condition,x,y)

- 满足条件(condition)，输出x，不满足输出y。
- np.where(condition), 输出满足condition条件的元素的下标。
- torch.where用法与其类似，不过输入数据必须为tensor类型。

> https://www.cnblogs.com/massquantity/p/8908859.html



# 7. dict.items()

- 以列表返回可遍历的(键, 值) 元组数组。

示例代码：

```python
#!/usr/bin/python
# coding=utf-8
 
dict = {'Google': 'www.google.com', 'Runoob': 'www.runoob.com', 'taobao': 'www.taobao.com'}
 
print "字典值 : %s" %  dict.items()
 
# 遍历字典列表
for key,values in  dict.items():
    print key,values
```

输出结果：

```
字典值 : [('Google', 'www.google.com'), ('taobao', 'www.taobao.com'), ('Runoob', 'www.runoob.com')]
Google www.google.com
taobao www.taobao.com
Runoob www.runoob.com
```

> https://www.runoob.com/python/att-dictionary-items.html

ps：

pytorch中有一个tensor.item()，区别在于item()取出单元素张量的元素值并返回该值，保持原元素类型不变。,即：原张量元素为整形，则返回整形，原张量元素为浮点型则返回浮点型，但是返回值的精度更高。

> https://blog.csdn.net/weixin_44739213/article/details/108659763

# 8. __call__

![__call__](C:\Users\acer-pc\Desktop\办公\自己写的资料\picture\常见预处理指令\__call__.png)

在类中创建了__call__函数，在调用此类的对象的时候，直接可以在对象后面加括号进行调用。

# 9. zip()

1. **zip()** 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。
2. 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。

```
>>>a = [1,2,3]
>>> b = [4,5,6]
>>> c = [4,5,6,7,8]
>>> zipped = zip(a,b)     # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]
>>> zip(a,c)              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
>>> zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
[(1, 2, 3), (4, 5, 6)]
```

> https://www.runoob.com/python/python-func-zip.html



# 10. dict()

> https://www.cnblogs.com/wz123/p/11975165.html



# 11. np.power()

power(x, y) 函数，计算 x 的 y 次方。

- x 和 y 为单个数字：

```
import numpy as np

print(np.power(2, 3))  # 8
```

​	**分析**：2 的 3 次方。

- x 为列表，y 为单个数字：

```
print(np.power([2,3,4], 3))  #[ 8 27 64]
```

​	**分析**：分别求 2， 3， 4 的 3 次方。

- x 为单个数字，y 为列表：

```
print(np.power(2, [2,3,4]))  # [ 4 8 16]
```

​	**分析**：分别求 2的 2， 3， 4 次方。

- x 和 y 为列表：

```
print(np.power([2,3], [3,4]))  # [ 8 81]
```

​	**分析：**分别求 2 的 3 次方和 3 的 4 次方。



# 12. np.isinf()

```
>>> np.isinf(np.inf)
True
>>> np.isinf(np.nan)
False
>>> np.isinf(np.NINF)
True
>>> np.isinf([np.inf, -np.inf, 1.0, np.nan])
array([ True,  True, False, False], dtype=bool)
```



# 13. np.tile()

Numpy的 **tile()** 函数，就是将原矩阵横向、纵向地复制。**tile** 是瓷砖的意思，顾名思义，这个函数就是把数组像瓷砖一样铺展开来。

```
mat = array([[1,2], [3, 4]])
```

**横向：**

```
tile(mat, (1, 4))
# 等同于
tile(mat, 4)
```

**结果：**

```
[[1 2 1 2 1 2 1 2]
 [3 4 3 4 3 4 3 4]]
```

> https://www.jianshu.com/p/9519f1984c70



# 14. torch.mul()、torch.mm()、torch.matmul()

1. torch.mul(a, b)是矩阵a和b对应位相乘，a和b的维度必须相等，比如a的维度是(1, 2)，b的维度是(1, 2)，返回的仍是(1, 2)的矩阵；
2. torch.mm(a, b)是矩阵a和b矩阵相乘，比如a的维度是(1, 2)，b的维度是(2, 3)，返回的就是(1, 3)的矩阵。
3. torch.matmul()也是一种类似于矩阵相乘操作的tensor联乘操作。但是它可以利用python 中的广播机制，处理一些维度不同的tensor结构进行相乘操作。

> https://www.jianshu.com/p/e277f7fc67b3



# 15. np.empty()

numpy.empty(shape，dtype=float,order='C')

shape表示维度

dtype为数据类型

order为保存数据是按行还是按列

在np.empty()参数输入需要创建的数组各维度的大小,得到对应维度的数组，，没有任何初始化，因此数据为生成的**随机数**。

> https://zhuanlan.zhihu.com/p/150705668



# 16. enumerate()

enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。

用法为：

```
enumerate(sequence, [start=0])
```

- sequence -- 一个序列、迭代器或其他支持迭代对象。
- start -- 下标起始位置。

代码示例：

```
>>>seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))       # 下标从 1 开始
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

> https://www.runoob.com/python/python-func-enumerate.html



# 17. 数组运算

![数组运算](C:\Users\acer-pc\Desktop\办公\自己写的资料\picture\常见预处理指令\数组运算.png)

详细内容参考资料[TensorFlow2.0](https://www.bilibili.com/video/BV1hK411w7ei?p=31)，拓展一下

- torch.sub()，相当于tensor1.sub(tensor2)

- torch.add()，相当于tensor1.add(tensor2)

- torch.mul()，相当于tensor1.mul(tensor2)

- torch.div()，相当于tensor1.div(tensor2)

  以上都是元素对应操作,直接对tensor进行+，-，*，/，也是用的元素对应操作。

参考自[csdn](https://blog.csdn.net/weixin_40802676/article/details/104231745)



# 18. 有序字典（OrderedDict）

有序字典会按照插入顺序输出。

![img](https://pic1.zhimg.com/80/v2-854b7eaaf7da3da4eb14a5bc01852a4c_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-a45e13c8a9031315d31a864ae3519572_720w.jpg)

有序字典的作用只是记住元素插入顺序并按顺序输出。如果有序字典中的元素一开始就定义好了，后面没有插入元素这一动作，那么遍历有序字典，其输出结果仍然是无序的，因为缺少了有序插入这一条件，所以此时有序字典就失去了作用，所以有序字典一般用于动态添加并需要按添加顺序输出的时候。

![img](https://pic4.zhimg.com/80/v2-86bb2598d83edaf0a87e579ebfea2843_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-106855e481ad7a58b84ff403eb81f5cd_720w.jpg)

[知乎](https://zhuanlan.zhihu.com/p/98946805)



# 19. tensor转换成array

下面将将tensor转成numpy的几种情况

1. GPU中的Variable变量：

```
a.cuda().data.cpu().numpy()
```

2. GPU中的tensor变量：

```
a.cuda().cpu().numpy()
```



3. CPU中的Variable变量：

   ```
   a.data.numpy()
   ```

4. CPU中的tensor变量：

```
a.numpy()
```

总结：

.cuda()是读取GPU中的数据

.data是读取Variable中的tensor

.cpu是把数据转移到cpu上

.numpy()把tensor变成numpy



作者：不太聪明的亚子
链接：https://www.jianshu.com/p/e9074a6f408d
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 20. vars(object)

返回对象的 __dict__ 属性：（返回的是一个字典，在预处理中，常常用于输出args里设置的超参数）

```
class Person:
  name = "John"
  age = 36
  country = "norway"

x = vars(Person)
```

输出为

```
C:\Users\My Name>python python_ref_vars.py
{'__module__': '__main__', 'name': 'Bill', 'age': 63, 'country': 'USA', '__dict__': <attribute '__dict__' of 'Person' objects>, '__weakref__': <attribute '__weakref__' of 'Person' objects>, '__doc__': None}
```

vars() 函数返回对象的 __dic__ 属性。

__dict__ 属性是包含对象的可变属性的字典。



# 21. setattr与getattr

**setattr()** 函数对应函数 [getattr()](https://www.runoob.com/python/python-func-getattr.html)，用于设置属性值，该属性不一定是存在的。

1. 语法

setattr() 语法：

```
setattr(object, name, value)
```

2. 参数

- object -- 对象。
- name -- 字符串，对象属性。
- value -- 属性值。

3. 返回值

无。

4. 实例

以下实例展示了 setattr() 函数的使用方法：

对已存在的属性进行赋值：

```
>>>class A(object):
...     bar = 1
... 
>>> a = A()
>>> getattr(a, 'bar')          # 获取属性 bar 值
1
>>> setattr(a, 'bar', 5)       # 设置属性 bar 值
>>> a.bar
5
```

如果属性不存在会创建一个新的对象属性，并对属性赋值：

```
>>>class A():
...     name = "runoob"
... 
>>> a = A()
>>> setattr(a, "age", 28)
>>> print(a.age)
28
>>>
```

[菜鸟教程](https://www.runoob.com/python/python-func-setattr.html)



# 22. filter()函数

**filter()** 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。

该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。

```
filter(function, iterable)
```

- function -- 判断函数。
- iterable -- 可迭代对象。

示例代码

```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import math
def is_sqr(x):
    return math.sqrt(x) % 1 == 0
 
newlist = filter(is_sqr, range(1, 101))
print(newlist)
```

输出结果为：

```
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

摘抄自[菜鸟](https://www.runoob.com/python/python-func-filter.html)



# 23. np.stack()

1.当axis=0时，

```
x1 = np.arange(9).reshape((3,3))
x2 = np.arange(10,19,1).reshape((3,3))

y2 = np.stack((x1,x2),axis=0)

输出：
    [[[ 0  1  2]
      [ 3  4  5]
      [ 6  7  8]]

     [[10 11 12]
      [13 14 15]
      [16 17 18]]]
    
    'y2.shape': (2,3,3)
```

np.stack的官方解释为 对指定axis增加维度，
 我们发现y2.shape为（2,3,3），注意x1.shape为（3,3）也可以看做（1,3,3），
 当给x1的axis = 0也就是第一维增加一维后就变成了（2,3,3），这刚好是y2.shape，
 那x1增加的这个维度的内容用什么来填充呢？当然是x2了！（所以，也要明白的就是x1和x2的shape一定要相同）

2.当axis=1时

```python
x1 = np.arange(9).reshape((3,3))
x2 = np.arange(10,19,1).reshape((3,3))

y2 = np.stack((x1,x2),axis=1)

输出：
    [[[ 0  1  2]
      [10 11 12]]

     [[ 3  4  5]
      [13 14 15]]

     [[ 6  7  8]
      [16 17 18]]]
    
    'y2.shape': (3,2,3)
```

3.axis=2时

```python
x1 = np.arange(9).reshape((3,3))
x2 = np.arange(10,19,1).reshape((3,3))

y2 = np.stack((x1,x2),axis=1)

输出：
    [[[ 0 10]
      [ 1 11]
      [ 2 12]]

     [[ 3 13]
      [ 4 14]
      [ 5 15]]

     [[ 6 16]
      [ 7 17]
      [ 8 18]]]
    
    'y2.shape':(3,3,2)
```

作者：yalesaleng
链接：https://www.jianshu.com/p/39112a4c0616
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 24 对字典的键值进行排序用sorted

sorted(iterable,key,reverse)，sorted一共有iterable，key，reverse这三个参数。其中iterable表示可以迭代的对象，例如可以是dict.items()、dict.keys()等，**key是一个函数，用来选取参与比较的元素**，reverse则是用来指定排序是倒序还是顺序，reverse=true则是倒序（从大到小），reverse=false则是顺序（从小到大），默认是reverse=false。



1. 要对字典按照key排序，可以直接调用sorted函数。

```
my_dict = {'lilee':25, 'age':24, 'phone':12}
sorted(my_dict.keys())
```

结果为

```
['age', 'lilee', 'phone']
```

2. 按照value值排序

```
d = {'lilee':25, 'wangyan':21, 'liqun':32, 'age':19}
sorted(d.items(), key=lambda item:item[1])
```

结果为

```
[('age',19),('wangyan',21),('lilee',25),('liqun',32)]
```



参考自

[csdn](https://blog.csdn.net/laobai1015/article/details/85114570)
